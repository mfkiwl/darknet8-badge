#include <stdio.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "freertos/event_groups.h"
#include "esp_system.h"
#include "esp_log.h"

#include <nvs.h>
#include <nvs_flash.h>

#include <time.h>

#include "string.h"
#include "exploitable.h"
#include "game_master.h"

const char* EXPLOITABLE_LOGTAG = "ExploitableGame";

#define AVAILABLE_LEVELS (8)
uint32_t cur_level = 0;
void* levels[AVAILABLE_LEVELS];

uint32_t g_nvs_handle = 0;

static void setCurrentLevel(uint32_t lvlid)
{
	cur_level = lvlid;
	nvs_set_u32(g_nvs_handle, "exp_cur_level", cur_level);
	return;
}

static void secretLevel(GameMsg* msg)
{
	SendStringResponse(msg, "Welcome to the secret level!\n");
	SendWinResponse(msg, "<)935c25$#)?;!-1&+7"); // {flag:zerpzerpzerp}
	return;
}

static void badLevel(GameMsg* msg)
{
	SendStringResponse(msg, "Bad level.\n");
}

static bool level5_greeting = false;
static void level5(GameMsg* msg)
{
	if (!msg->length || !level5_greeting)
	{
		SendStringResponse(msg, "That's all Gourry wrote!\n");
		level5_greeting = true;
	}
	return;
}

static bool level4_greeting = false;
static void level4(GameMsg* msg)
{
	if (!msg->length || !level4_greeting)
	{
		SendStringResponse(msg, "Level 4\n");
		level4_greeting = true;
	}
	return;
}

static bool level3_greeting = false;
static void level3(GameMsg* msg)
{
	if (!msg->length || !level3_greeting)
	{
		SendStringResponse(msg, "Level 3\n");
		level3_greeting = true;
	}
	return;
}

static bool level2_greeting = false;
static void level2(GameMsg* msg)
{
	static int password2;
	static int guess;
	static long int start_time2;
	if (!msg->length || !level2_greeting)
	{
		SendStringResponse(msg, "Level 2\n");
		SendStringResponse(msg, "Input the password. 4*[0-9]\n");
		password2 = rand();
		level2_greeting = true;
		return;
	}
	else if ((time(0) - start_time2) > 30)
	{
		SendStringResponse(msg, "TIMED OUT\n");
		SendStringResponse(msg, "Password reset.\n");
		password2 = rand();
		start_time2 = time(0);
		return;
	}
	guess = atoi(msg->data);
	if (guess == password2)
	{
		SendWinResponse(msg, "<)935c\n<?=7\x16<2<)"); // {flag:BlindLuck}
		SendStringResponse(msg, "Moving to level 3...");
		setCurrentLevel(3);
	}
	else
		SendStringResponse(msg, "Nope.\n");
	return;
}

static bool level1_greeting = false;
static void level1(GameMsg* msg)
{
	static char password[8];
	static long int start_time1;
	int result = 0;
	char* return_msg;
	int i = 0;
	if (!msg->length || !level1_greeting)
	{
		SendStringResponse(msg, "Level 1\n");
		SendStringResponse(msg, "Input the password. 8*[a-z]\n");
		SendStringResponse(msg, "You have 30 seconds.\n");
		for (i = 0; i < 8; i++)
			password[i] = (rand() % (122 - 97 + 1)) + 97;
		start_time1 = time(0);
		level1_greeting = true;
		return;
	}
	else if ((time(0) - start_time1) > 30)
	{
		SendStringResponse(msg, "TIMED OUT\n");
		SendStringResponse(msg, "Password reset.\n");
		for (i = 0; i < 8; i++)
			password[i] = (rand() % (122 - 97 + 1)) + 97;
		start_time1 = time(0);
		return;
	}
	//ESP_LOGI(EXPLOITABLE_LOGTAG, "time(0): %ld, start_time1: %ld\n", time(0), start_time1);
	result = strncmp(password, msg->data, 8);
	if (!result)
	{
		SendStringResponse(msg, "Very good\n");
		SendWinResponse(msg, "<)935c\x12?9#:.0""\x15""8;$2>+%"); //{flag: ZoopityDoopity}
		SendStringResponse(msg, "Moving to level 2...\n");
		setCurrentLevel(2);
	}
	else
	{
		return_msg = (char*)malloc(5);
		memset(return_msg, '\n', 5);
		sprintf(return_msg, "%d", result);
		SendResponse(msg, return_msg, 5);
	}
	return;
}

static bool level0_greeting = false;
static char exp0_flag[] = "Very Good! Now Echo This: ZOOP";
static void level0(GameMsg* msg)
{
	char* tmp = nullptr;
	char* ftmp = nullptr;
	int tmp_length = 0;
	if (!msg->length || !level0_greeting)
	{
		SendStringResponse(msg, "Level 0\n");
		SendStringResponse(msg, "You breath... and it echoes.\n");
		SendStringResponse(msg, "Wow you breath loudly.......\n");
		level0_greeting = true;
		return;
	}

	if ((msg->length >= 4) && (!strncmp("ZOOP", msg->data, 4)))
	{
		SendWinResponse(msg, "<)935c\x0f\"32\'\x1d&>08-\x16%=?9,!"); //{flag:GreatGooglyMoogly}
		SendStringResponse(msg, "Moving to level 1...\n");
		setCurrentLevel(1);
	}

	tmp_length = (strlen(exp0_flag) > msg->length) ? strlen(exp0_flag) : msg->length;
	tmp = (char*)malloc(tmp_length);
	snprintf(tmp, tmp_length, msg->data, exp0_flag);
	ftmp = (char*)malloc(msg->length + 1);
	memcpy(ftmp, tmp, msg->length);
	ftmp[msg->length] = '\n';
	free(tmp);
	SendResponse(msg, ftmp, msg->length + 1);
	return;
}

void ExploitableGameTask::commandHandler(GameMsg* msg)
{
	ESP_LOGI(LOGTAG, "Exploitable Game Received a Message : %p", msg);

	if (!msg->data)
	{
		SendStringResponse(msg, "Welcome to the exploitable game\n");
		SendStringResponse(msg, "To select a level, write 'level #'\n");
		SendStringResponse(msg, "Otherwise you will progress from level 0 upward\n");
		SendStringResponse(msg, "There are 5 levels (0-4)\n");
	}
	else if (!strncmp(msg->data, "level ", 6))
	{
		int level_num = 0;
		if (msg->length < 7)
		{
			SendStringResponse(msg, "Invalid level selection\n");
			return;
		}
		level_num = atoi(&msg->data[6]);
		if (level_num < 0 || level_num == 6 || level_num > 8)
		{
			SendStringResponse(msg, "Bad number in level selection\n");
			return;
		}
		else
		{
			SendStringResponse(msg, "Setting level.\n");
			setCurrentLevel(level_num);
		}
	}

	((void (*)(GameMsg*))levels[cur_level])(msg);
	return;
}

#define CmdQueueTimeout ((TickType_t) 1000 / portTICK_PERIOD_MS)
void ExploitableGameTask::run(void* data)
{
	GameMsg* msg = nullptr;
	while(1)
	{
		if (xQueueReceive(this->GameQueueHandle, &msg, CmdQueueTimeout))
		{
			if (msg != nullptr)
			{
				this->commandHandler(msg);
				free(msg->data);
				free(msg);
			}
		}
	}
}

bool ExploitableGameTask::init()
{
	this->GameQueueHandle = xQueueCreateStatic(GAME_QUEUE_SIZE, GAME_MSG_SIZE,
		gameQueueBuffer, &GameQueue);

	// setup the level pointers, we do it this way so hopefully someone finds
	// the secret level :3
	levels[0] = (void*)level0;
	levels[1] = (void*)level1;
	levels[2] = (void*)level2;
	levels[3] = (void*)level3;
	levels[4] = (void*)level4;
	levels[5] = (void*)level5;
	levels[6] = (void*)badLevel; // unreachable
	levels[7] = (void*)badLevel;
	levels[8] = (void*)secretLevel;

	if (nvs_open("storage", NVS_READWRITE, &g_nvs_handle) != ESP_OK)
	{
		ESP_LOGE(LOGTAG, "FAILED TO OPEN NVS");
		return false;
	}

	if (nvs_get_u32(g_nvs_handle, "exp_cur_level", &cur_level) != ESP_OK)
	{
		cur_level = 0;
		nvs_set_u32(g_nvs_handle, "exp_cur_level", cur_level);
	}

	return true;
}

ExploitableGameTask::ExploitableGameTask(const std::string &tName, uint16_t stackSize, uint8_t priority)
	: Task(tName, stackSize, priority)
{
	this->LOGTAG = EXPLOITABLE_LOGTAG;
	ESP_LOGI(LOGTAG, "Created");
}

ExploitableGameTask::~ExploitableGameTask()
{
	// TODO:
	ESP_LOGI(LOGTAG, "DESTROY");
}
