#include <stdio.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "freertos/event_groups.h"
#include "esp_system.h"
#include "esp_log.h"

#include "string.h"
#include "exploitable.h"
#include "game_master.h"

const char* EXPLOITABLE_LOGTAG = "ExploitableGame";

#define AVAILABLE_LEVELS (1)
uint8_t cur_level = 0; // TODO: stored in nvs
void* levels[AVAILABLE_LEVELS];

typedef struct
{
	GameDataType dtype;
	char data;
} GameData;

void SendResponse(GameMsg* msg, char* data, uint8_t size)
{
	// split into chunks?
	GameMsg* omsg = nullptr;
	if (msg->returnQueue)
	{
		omsg = (GameMsg*)malloc(sizeof(GameMsg));
		memset(omsg, '\0', sizeof(GameMsg));
		omsg->length = size;
		omsg->data = data;
		omsg->returnQueue = nullptr;
		xQueueSend(msg->returnQueue, (void*)&omsg, (TickType_t)100);
	}
	else
		free(data);
	return;
}

// Helper so we can send pre-defined strings without writing this line over and over
void SendStringResponse(GameMsg* msg, const char* stringToCopy)
{
	int size = strlen(stringToCopy);
	char* tmp = (char*)malloc(size);
	memcpy(tmp, stringToCopy, size);
	SendResponse(msg, tmp, size);
	return;
}

void SendCopyResponse(GameMsg* msg, const char* copyme, uint8_t size)
{
	char* tmp = (char*)malloc(size);
	memcpy(tmp, copyme, size);
	SendResponse(msg, tmp, size);
	return;
}

char welcomeStr[] = "Welcome to level\0";
static void welcomeLevel(GameMsg* msg, uint32_t level)
{
	char* welcome = (char*)malloc(strlen(welcomeStr) + 10);
	sprintf(welcome, "%s %d\n", welcomeStr, level);
	SendResponse(msg, welcome, strlen(welcome));
}


static void level0(GameMsg* msg)
{
	GameData* gdata = (GameData*)msg->data;
	char* data = &gdata->data;
	int key = 0x12345678;
	char boofer[16];

	welcomeLevel(msg, 0);

	strncpy(boofer, data, 20);

	if (key == 0x42424242)
		SendStringResponse(msg, "Very good: {flag: zoopzoop}\n\0");
	return;
}

char initStr[] = "Welcome to the exploitable game\n";
void ExploitableGameTask::commandHandler(GameMsg* msg)
{
	ESP_LOGI(LOGTAG, "Exploitable Game Received a Message : %p", msg);
	GameData* gdata = (GameData*)msg->data;

	if (gdata->dtype == GAME_INIT)
		SendCopyResponse(msg, initStr, strlen(initStr));
	((void (*)(GameMsg*))levels[cur_level])(msg);
	return;
}

#define CmdQueueTimeout ((TickType_t) 1000 / portTICK_PERIOD_MS)
void ExploitableGameTask::run(void* data)
{
	GameMsg* msg = nullptr;
	while(1)
	{
		if (xQueueReceive(this->GameQueueHandle, &msg, CmdQueueTimeout))
		{
			if (msg != nullptr)
			{
				this->commandHandler(msg);
				free(msg->data);
				free(msg);
			}
		}
	}
}

bool ExploitableGameTask::init()
{
	this->GameQueueHandle = xQueueCreateStatic(GAME_QUEUE_SIZE, GAME_MSG_SIZE,
		gameQueueBuffer, &GameQueue);

	// setup the level pointers, we do it this way so hopefully someone finds
	// the secret level :3
	levels[0] = (void*)level0;

	return true;
}

ExploitableGameTask::ExploitableGameTask(const std::string &tName, uint16_t stackSize, uint8_t priority)
	: Task(tName, stackSize, priority)
{
	this->LOGTAG = EXPLOITABLE_LOGTAG;
	ESP_LOGI(LOGTAG, "Created");
}

ExploitableGameTask::~ExploitableGameTask()
{
	// TODO:
	ESP_LOGI(LOGTAG, "DESTROY");
}
